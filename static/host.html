<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Mirror - Host</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin: 16px; }
    .topbar { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .badge { padding: 4px 10px; border-radius: 999px; background:#f2f2f2; }
    .badge.on { background:#e6f4ea; }
    .badge.off { background:#fde8e8; }
    .badge.warn { background:#fff4cc; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top: 10px; }
    button { padding: 8px 12px; }
    button.active { outline: 2px solid #333; }
    input, select { padding: 8px 10px; }
    #viewerLink { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    #canvasWrap { margin-top: 12px; border: 1px solid #ddd; border-radius: 10px; padding: 10px; }
    #pdfCanvas { width: 100%; height: auto; }
    .hint { color:#666; font-size: 13px; }
    .error { color:#b00020; font-size: 13px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h2>PDF Mirror (조정자 화면)</h2>

  <div class="topbar">
    <span class="badge" id="roomBadge">room: -</span>
    <span class="badge warn" id="wsBadge">WS: 연결중...</span>
    <span class="badge" id="controllerBadge">조정권: -</span>
    <button id="btnOn">조정 ON (즉시 takeover)</button>
    <button id="btnOff">조정 OFF (비우기)</button>
  </div>

  <div class="row">
    <label>PDF 선택:</label>
    <select id="pdfSelect">
      <option value="1">PDF 1</option>
      <option value="2">PDF 2</option>
      <option value="3">PDF 3</option>
    </select>

    <label>페이지:</label>
    <input id="pageInput" type="number" min="1" value="1" style="width:90px;" />
    <button id="btnGo">이동</button>
    <button id="btnPrev">이전</button>
    <button id="btnNext">다음</button>
  </div>

  <p class="hint">
    관전자 링크: <span id="viewerLink"></span>
  </p>
  <p class="error" id="err"></p>

  <div id="canvasWrap">
    <div class="hint">미리보기(조정자): 현재 선택된 PDF/페이지를 렌더링</div>
    <canvas id="pdfCanvas"></canvas>
  </div>

  <!-- ✅ PDF.js 모듈 + 앱 로직을 한 번에 -->
  <script type="module">
    // ---- PDF.js (ESM) ----
    import * as pdfjsLib from "/static/pdfjs/pdf.min.js";
    pdfjsLib.GlobalWorkerOptions.workerSrc = "/static/pdfjs/pdf.worker.min.js";

    // ---- room + ws ----
    const params = new URLSearchParams(location.search);
    const room = params.get("room") || "abcd";
    document.getElementById("roomBadge").textContent = "room: " + room;

    const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/" + room;
    const ws = new WebSocket(wsUrl);

    const wsBadge = document.getElementById("wsBadge");
    const errEl = document.getElementById("err");

    let myId = null;
    let controllerId = null;

    let currentPdfId = 1;
    let currentPage = 1;

    // ---- pdf render ----
    let pdfDoc = null;
    const canvas = document.getElementById("pdfCanvas");
    const ctx = canvas.getContext("2d");

    function pdfUrl(pdfId){
      return `/static/pdf/pdf${pdfId}.pdf`;
    }

    function setError(msg){
      errEl.textContent = msg || "";
    }

    function isController(){
      return myId && controllerId && myId === controllerId;
    }

    function updateControllerUI(){
      const badge = document.getElementById("controllerBadge");
      const onBtn = document.getElementById("btnOn");
      if(!controllerId){
        badge.textContent = "조정권: 없음";
        badge.className = "badge off";
      } else if (isController()){
        badge.textContent = "조정권: 나(ON)";
        badge.className = "badge on";
      } else {
        badge.textContent = "조정권: 다른 사람";
        badge.className = "badge off";
      }
      // ON 버튼 눌린 표시(내가 조정자면 active)
      if (isController()) onBtn.classList.add("active");
      else onBtn.classList.remove("active");
    }

    function updateInputs(){
      document.getElementById("pdfSelect").value = String(currentPdfId);
      document.getElementById("pageInput").value = String(currentPage);
    }

    async function loadAndRender(pdfId, page){
      setError("");
      try{
        const loadingTask = pdfjsLib.getDocument(pdfUrl(pdfId));
        pdfDoc = await loadingTask.promise;

        const p = Math.max(1, Math.min(page, pdfDoc.numPages));
        const pageObj = await pdfDoc.getPage(p);

        const viewport = pageObj.getViewport({ scale: 1.2 });
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        await pageObj.render({ canvasContext: ctx, viewport }).promise;
      }catch(e){
        setError("PDF 렌더링 오류:\n" + (e?.message || String(e)));
      }
    }

    function sendState(pdfId, page){
      ws.send(JSON.stringify({type:"set_state", pdf_id: pdfId, page: page}));
    }

    // ---- controls ----
    document.getElementById("btnOn").onclick = () => {
      setError("");
      ws.send(JSON.stringify({type:"controller_on"}));
    };
    document.getElementById("btnOff").onclick = () => {
      setError("");
      ws.send(JSON.stringify({type:"controller_off"}));
    };

    document.getElementById("btnGo").onclick = () => {
      setError("");
      const pdfId = parseInt(document.getElementById("pdfSelect").value, 10);
      const page = parseInt(document.getElementById("pageInput").value, 10) || 1;
      sendState(pdfId, page);
    };

    document.getElementById("btnPrev").onclick = () => {
      setError("");
      sendState(currentPdfId, Math.max(1, currentPage - 1));
    };

    document.getElementById("btnNext").onclick = () => {
      setError("");
      sendState(currentPdfId, currentPage + 1);
    };

    document.getElementById("pdfSelect").onchange = () => {
      setError("");
      const pdfId = parseInt(document.getElementById("pdfSelect").value, 10);
      sendState(pdfId, 1);
    };

    // viewer 링크 표시
    document.getElementById("viewerLink").textContent =
      `${location.origin}/view?room=${encodeURIComponent(room)}`;

    // ---- websocket handlers ----
    ws.onopen = () => {
      wsBadge.textContent = "WS: 연결됨";
      wsBadge.className = "badge on";
    };

    ws.onmessage = async (e) => {
      const msg = JSON.parse(e.data);

      if(msg.type === "hello"){
        myId = msg.client_id;
        updateControllerUI();
        return;
      }

      if(msg.type === "snapshot"){
        controllerId = msg.controller_id;
        currentPdfId = msg.pdf_id;
        currentPage = msg.page;
        updateControllerUI();
        updateInputs();
        await loadAndRender(currentPdfId, currentPage);
        return;
      }

      if(msg.type === "controller_changed"){
        controllerId = msg.controller_id;
        updateControllerUI();
        return;
      }

      if(msg.type === "state_changed"){
        currentPdfId = msg.pdf_id;
        currentPage = msg.page;
        updateInputs();
        await loadAndRender(currentPdfId, currentPage);
        return;
      }

      if(msg.type === "error"){
        setError(msg.message || "오류");
        return;
      }
    };

    ws.onerror = () => {
      wsBadge.textContent = "WS: 오류";
      wsBadge.className = "badge off";
      setError("WebSocket 연결 오류(브라우저 콘솔 확인)");
    };

    ws.onclose = () => {
      wsBadge.textContent = "WS: 종료됨";
      wsBadge.className = "badge off";
      setError("연결이 종료되었습니다(페이지 새로고침 후 재시도).");
    };
  </script>
</body>
</html>
