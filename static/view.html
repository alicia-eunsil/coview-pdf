<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Mirror - Viewer</title>

  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      margin: 16px;
    }
    .topbar {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      background:#f2f2f2;
      font-size: 13px;
    }
    .badge.on { background:#e6f4ea; }
    .badge.off { background:#fde8e8; }
    .badge.warn { background:#fff4cc; }

    button { padding: 8px 12px; }
    button.active { outline: 2px solid #333; }

    #canvasWrap {
      margin-top: 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 10px;
    }
    #pdfCanvas {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .hint { color:#666; font-size: 13px; }
    .error { color:#b00020; font-size: 13px; white-space: pre-wrap; }
  </style>
</head>

<body>
  <h2>PDF Mirror (ê´€ì „ì í™”ë©´)</h2>

  <div class="topbar">
    <span class="badge" id="roomBadge">room: -</span>
    <span class="badge warn" id="wsBadge">WS: ì—°ê²°ì¤‘...</span>
    <span class="badge" id="controllerBadge">ì¡°ì •ê¶Œ: -</span>

    <button id="btnOn">ì¡°ì • ON</button>
    <button id="btnOff">ì¡°ì • OFF</button>

    <span class="hint">â€» ì¡°ì •ìê°€ ì•„ë‹ˆë©´ í˜ì´ì§€/íŒŒì¼ ë³€ê²½ ë¶ˆê°€</span>
  </div>

  <p class="error" id="err"></p>

  <div id="canvasWrap">
    <div class="hint" id="statusLine">ë¡œë”© ì¤‘...</div>
    <canvas id="pdfCanvas"></canvas>
  </div>

  <script type="module">
    import * as pdfjsLib from "/static/pdfjs/pdf.min.js";
    pdfjsLib.GlobalWorkerOptions.workerSrc = "/static/pdfjs/pdf.worker.min.js";

    /* -------- í‚¤ë³´ë“œ í˜ì´ì§€ ì´ë™ ì°¨ë‹¨ (ê´€ì „ì ë³´í˜¸) -------- */
    window.addEventListener(
      "keydown",
      (ev) => {
        const keys = ["ArrowLeft","ArrowRight","PageUp","PageDown"," "];
        if (keys.includes(ev.key)) ev.preventDefault();
      },
      { passive: false }
    );

    /* -------- Room / WebSocket -------- */
    const params = new URLSearchParams(location.search);
    const room = params.get("room") || "GJF00";
    document.getElementById("roomBadge").textContent = "room: " + room;

    const wsUrl =
      (location.protocol === "https:" ? "wss://" : "ws://") +
      location.host +
      "/ws/" +
      room;

    const ws = new WebSocket(wsUrl);

    const wsBadge = document.getElementById("wsBadge");
    const errEl = document.getElementById("err");

    let myId = null;
    let controllerId = null;

    // í˜„ì¬ ìƒíƒœ(ì„œë²„ì—ì„œ ì˜¤ëŠ” ê°’)
    let currentPdfId = 1;
    let currentPage = 1;

    /* -------- PDF Canvas -------- */
    let pdfDoc = null;

    // âœ… ìºì‹±ìš©: í˜„ì¬ ë¡œë“œë˜ì–´ ìˆëŠ” PDF id / ì´ í˜ì´ì§€
    let loadedPdfId = null;
    let totalPages = null;

    const canvas = document.getElementById("pdfCanvas");
    const ctx = canvas.getContext("2d");

    // ë™ì‹œ ë Œë” ë°©ì§€
    let renderTask = null;
    let renderToken = 0;

    function pdfUrl(pdfId){
      return `/static/pdf/pdf${pdfId}.pdf`;
    }

    function setError(msg){
      errEl.textContent = msg || "";
    }

    function isController(){
      return myId && controllerId && myId === controllerId;
    }

    function updateControllerUI(){
      const badge = document.getElementById("controllerBadge");
      const onBtn = document.getElementById("btnOn");

      if(!controllerId){
        badge.textContent = "ì¡°ì •ê¶Œ: ì—†ìŒ";
        badge.className = "badge off";
      } else if (isController()){
        badge.textContent = "ì¡°ì •ê¶Œ: ë‚˜(ON)";
        badge.className = "badge on";
      } else {
        badge.textContent = "ì¡°ì •ê¶Œ: ë‹¤ë¥¸ ì‚¬ëŒ";
        badge.className = "badge off";
      }

      if (isController()) onBtn.classList.add("active");
      else onBtn.classList.remove("active");
    }

    function updateStatusLine(){
      const who = !controllerId
        ? "ì—†ìŒ"
        : (isController() ? "ë‚˜" : "ë‹¤ë¥¸ ì‚¬ëŒ");

      const total = totalPages ? ` / ${totalPages}` : "";
      document.getElementById("statusLine").textContent =
        `í˜„ì¬: PDF ${currentPdfId} | ${currentPage}${total} í˜ì´ì§€  |  ì¡°ì •ì: ${who}`;
    }

    /* ==================================================
       âœ… PDF ë Œë” (ìºì‹± + ë™ì‹œ ë Œë” ë°©ì§€ + iOS ë’¤ì§‘í˜ ë°©ì§€)
       ================================================== */
    async function loadAndRender(pdfId, page){
      setError("");
      const myToken = ++renderToken;

      try{
        // ì§„í–‰ ì¤‘ ë Œë” ì·¨ì†Œ
        if (renderTask) {
          try { renderTask.cancel(); } catch(e) {}
          renderTask = null;
        }

        // âœ… PDF ë¡œë“œëŠ” pdfIdê°€ ë°”ë€” ë•Œë§Œ ìˆ˜í–‰(ìºì‹±)
        if (!pdfDoc || loadedPdfId !== pdfId) {
          // ë¡œë”© ì¤‘ í‘œì‹œë¥¼ ë¨¼ì € ê°±ì‹ (ì´ í˜ì´ì§€ëŠ” ì•„ì§ ëª¨ë¦„)
          totalPages = null;
          loadedPdfId = null;
          updateStatusLine();

          const loadingTask = pdfjsLib.getDocument(pdfUrl(pdfId));
          const newDoc = await loadingTask.promise;
          if (myToken !== renderToken) return;

          pdfDoc = newDoc;
          loadedPdfId = pdfId;
          totalPages = pdfDoc.numPages;
        }

        // ì—¬ê¸°ì„œë¶€í„°ëŠ” ê°™ì€ PDF ë¬¸ì„œ ë‚´ í˜ì´ì§€ ë Œë”ë§Œ ìˆ˜í–‰
        const p = Math.max(1, Math.min(page, pdfDoc.numPages));
        const pageObj = await pdfDoc.getPage(p);
        if (myToken !== renderToken) return;

        // ğŸ”‘ DPR ëŒ€ì‘ (iOS/Safari ë’¤ì§‘í˜ ë°©ì§€ + ì„ ëª…ë„)
        const dpr = window.devicePixelRatio || 1;
        const viewport = pageObj.getViewport({ scale: 1.2 });

        canvas.width  = Math.floor(viewport.width  * dpr);
        canvas.height = Math.floor(viewport.height * dpr);
        canvas.style.width  = `${Math.floor(viewport.width)}px`;
        canvas.style.height = `${Math.floor(viewport.height)}px`;

        // ğŸ”‘ ìº”ë²„ìŠ¤ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        renderTask = pageObj.render({
          canvasContext: ctx,
          viewport
        });

        await renderTask.promise;
        renderTask = null;

        // âœ… ë Œë” ì„±ê³µ í›„ ìƒíƒœì¤„ ê°±ì‹ (ì´í˜ì´ì§€ í¬í•¨)
        updateStatusLine();

      } catch(e){
        const msg = e?.name || e?.message || String(e);
        if (
          String(msg).includes("RenderingCancelled") ||
          String(msg).includes("cancelled")
        ) return;

        setError("PDF ë Œë”ë§ ì˜¤ë¥˜:\n" + (e?.message || String(e)));
      }
    }

    /* -------- Buttons -------- */
    document.getElementById("btnOn").onclick = () => {
      setError("");
      ws.send(JSON.stringify({ type: "controller_on" }));
    };

    document.getElementById("btnOff").onclick = () => {
      setError("");
      ws.send(JSON.stringify({ type: "controller_off" }));
    };

    /* -------- WebSocket Handlers -------- */
    ws.onopen = () => {
      wsBadge.textContent = "WS: ì—°ê²°ë¨";
      wsBadge.className = "badge on";
    };

    ws.onmessage = async (e) => {
      const msg = JSON.parse(e.data);

      if(msg.type === "hello"){
        myId = msg.client_id;
        updateControllerUI();
        updateStatusLine();
        return;
      }

      if(msg.type === "snapshot"){
        controllerId = msg.controller_id;
        currentPdfId = msg.pdf_id;
        currentPage = msg.page;

        updateControllerUI();
        updateStatusLine();
        await loadAndRender(currentPdfId, currentPage);
        return;
      }

      if(msg.type === "controller_changed"){
        controllerId = msg.controller_id;
        updateControllerUI();
        updateStatusLine();
        return;
      }

      if(msg.type === "state_changed"){
        currentPdfId = msg.pdf_id;
        currentPage = msg.page;

        updateStatusLine(); // ë¨¼ì € ìˆ«ì ê°±ì‹ 
        await loadAndRender(currentPdfId, currentPage);
        return;
      }

      if(msg.type === "error"){
        setError(msg.message || "ì˜¤ë¥˜");
      }
    };

    ws.onerror = () => {
      wsBadge.textContent = "WS: ì˜¤ë¥˜";
      wsBadge.className = "badge off";
      setError("WebSocket ì˜¤ë¥˜ (ì½˜ì†” í™•ì¸)");
    };

    ws.onclose = () => {
      wsBadge.textContent = "WS: ì¢…ë£Œë¨";
      wsBadge.className = "badge off";
      setError("ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.");
    };
  </script>
</body>
</html>
