<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Mirror - Viewer</title>

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin:16px; }
    .topbar { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .badge { padding:4px 10px; border-radius:999px; background:#f2f2f2; font-size:13px; }
    .badge.on { background:#e6f4ea; }
    .badge.off { background:#fde8e8; }
    .badge.warn { background:#fff4cc; }
    button { padding:8px 12px; }
    button.active { outline:2px solid #333; }
    #canvasWrap { margin-top:12px; border:1px solid #ddd; border-radius:10px; padding:10px; }
    #pdfCanvas { max-width:100%; height:auto; display:block; }
    .hint { color:#666; font-size:13px; }
    .error { color:#b00020; font-size:13px; white-space:pre-wrap; }
  </style>
</head>

<body>
<h2>PDF Mirror (Viewer)</h2>

<div class="topbar">
  <span class="badge" id="roomBadge"></span>
  <span class="badge warn" id="wsBadge">WS: connecting…</span>
  <span class="badge" id="controllerBadge">Control: -</span>
  <button id="btnOn">Control ON</button>
  <button id="btnOff">Control OFF</button>
</div>

<p class="error" id="err"></p>

<div id="canvasWrap">
  <div class="hint" id="statusLine">Loading…</div>
  <canvas id="pdfCanvas"></canvas>
</div>

<script type="module">
import * as pdfjsLib from "/static/pdfjs/pdf.min.js";
pdfjsLib.GlobalWorkerOptions.workerSrc="/static/pdfjs/pdf.worker.min.js";

const room = "GJF00";
roomBadge.textContent="room: "+room;

const wsUrl=(location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws/"+room;
const ws=new WebSocket(wsUrl);

let myId=null, controllerId=null;
let currentPdfId=1, currentPage=1;
let pdfDoc=null, loadedPdfId=null, totalPages=null;

const canvas=pdfCanvas;
const ctx=canvas.getContext("2d");
let renderTask=null, renderToken=0;

function pdfUrl(id){ return `/static/pdf/pdf${id}.pdf`; }
function isController(){ return myId && controllerId===myId; }
function updateUI(){
  if(!controllerId){ controllerBadge.textContent="Control: none"; controllerBadge.className="badge off"; }
  else if(isController()){ controllerBadge.textContent="Control: you"; controllerBadge.className="badge on"; }
  else{ controllerBadge.textContent="Control: other"; controllerBadge.className="badge off"; }
  const total=totalPages?` / ${totalPages}`:"";
  statusLine.textContent=`PDF ${currentPdfId} | ${currentPage}${total} pages`;
}

async function loadAndRender(pdfId,page){
  const token=++renderToken;
  if(renderTask){ try{renderTask.cancel();}catch{} }
  if(!pdfDoc||loadedPdfId!==pdfId){
    const doc=await pdfjsLib.getDocument(pdfUrl(pdfId)).promise;
    if(token!==renderToken) return;
    pdfDoc=doc; loadedPdfId=pdfId; totalPages=doc.numPages;
  }
  const p=Math.max(1,Math.min(page,pdfDoc.numPages));
  const pg=await pdfDoc.getPage(p);
  const dpr=window.devicePixelRatio||1;
  const vp=pg.getViewport({scale:1.2});
  canvas.width=vp.width*dpr; canvas.height=vp.height*dpr;
  canvas.style.width=`${vp.width}px`; canvas.style.height=`${vp.height}px`;
  ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  renderTask=pg.render({canvasContext:ctx,viewport:vp});
  await renderTask.promise;
  updateUI();
}

btnOn.onclick=()=>ws.send(JSON.stringify({type:"controller_on"}));
btnOff.onclick=()=>ws.send(JSON.stringify({type:"controller_off"}));

ws.onopen=()=>{ wsBadge.textContent="WS: connected"; wsBadge.className="badge on"; };
ws.onmessage=async e=>{
  const m=JSON.parse(e.data);
  if(m.type==="hello"){ myId=m.client_id; updateUI(); return; }
  if(m.type==="snapshot"||m.type==="state_changed"){
    controllerId=m.controller_id ?? controllerId;
    currentPdfId=m.pdf_id; currentPage=m.page;
    await loadAndRender(currentPdfId,currentPage);
  }
};
</script>
</body>
</html>
