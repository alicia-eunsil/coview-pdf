<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Mirror - Viewer</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin: 16px; }
    .topbar { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .badge { padding: 4px 10px; border-radius: 999px; background:#f2f2f2; }
    .badge.on { background:#e6f4ea; }
    .badge.off { background:#fde8e8; }
    .badge.warn { background:#fff4cc; }
    button { padding: 8px 12px; }
    button.active { outline: 2px solid #333; }
    #canvasWrap { margin-top: 12px; border: 1px solid #ddd; border-radius: 10px; padding: 10px; }
    #pdfCanvas { width: 100%; height: auto; }
    .hint { color:#666; font-size: 13px; }
    .error { color:#b00020; font-size: 13px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h2>PDF Mirror (관전자 화면)</h2>

  <div class="topbar">
    <span class="badge" id="roomBadge">room: -</span>
    <span class="badge warn" id="wsBadge">WS: 연결중...</span>
    <span class="badge" id="controllerBadge">조정권: -</span>
    <button id="btnOn">조정 ON (즉시 takeover)</button>
    <button id="btnOff">조정 OFF (비우기)</button>
    <span class="hint">※ 조정자가 아니면 변경 불가(읽기 전용)</span>
  </div>

  <p class="error" id="err"></p>

  <div id="canvasWrap">
    <div class="hint" id="statusLine">로딩 중...</div>
    <canvas id="pdfCanvas"></canvas>
  </div>

  <script type="module">
    import * as pdfjsLib from "/static/pdfjs/pdf.min.js";
    pdfjsLib.GlobalWorkerOptions.workerSrc = "/static/pdfjs/pdf.worker.min.js";

    // 키보드 페이지 이동 차단
    window.addEventListener("keydown", (ev) => {
      const keys = ["ArrowLeft","ArrowRight","PageUp","PageDown"," "];
      if(keys.includes(ev.key)) ev.preventDefault();
    }, {passive:false});

    const params = new URLSearchParams(location.search);
    const room = params.get("room") || "abcd";
    document.getElementById("roomBadge").textContent = "room: " + room;

    const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/" + room;
    const ws = new WebSocket(wsUrl);

    const wsBadge = document.getElementById("wsBadge");
    const errEl = document.getElementById("err");

    let myId = null;
    let controllerId = null;
    let currentPdfId = 1;
    let currentPage = 1;

    let pdfDoc = null;
    const canvas = document.getElementById("pdfCanvas");
    const ctx = canvas.getContext("2d");

    function pdfUrl(pdfId){
      return `/static/pdf/pdf${pdfId}.pdf`;
    }
    function setError(msg){ errEl.textContent = msg || ""; }
    function isController(){ return myId && controllerId && myId === controllerId; }

    function updateControllerUI(){
      const badge = document.getElementById("controllerBadge");
      const onBtn = document.getElementById("btnOn");
      if(!controllerId){
        badge.textContent = "조정권: 없음";
        badge.className = "badge off";
      } else if (isController()){
        badge.textContent = "조정권: 나(ON)";
        badge.className = "badge on";
      } else {
        badge.textContent = "조정권: 다른 사람";
        badge.className = "badge off";
      }
      if (isController()) onBtn.classList.add("active");
      else onBtn.classList.remove("active");
    }

    function updateStatusLine(){
      const who = !controllerId ? "없음" : (isController() ? "나" : "다른 사람");
      document.getElementById("statusLine").textContent =
        `현재: PDF ${currentPdfId} / ${currentPage}p  |  조정자: ${who}`;
    }

    async function loadAndRender(pdfId, page){
      setError("");
      try{
        const loadingTask = pdfjsLib.getDocument(pdfUrl(pdfId));
        pdfDoc = await loadingTask.promise;

        const p = Math.max(1, Math.min(page, pdfDoc.numPages));
        const pageObj = await pdfDoc.getPage(p);

        const viewport = pageObj.getViewport({ scale: 1.2 });
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        await pageObj.render({ canvasContext: ctx, viewport }).promise;
      }catch(e){
        setError("PDF 렌더링 오류:\n" + (e?.message || String(e)));
      }
    }

    document.getElementById("btnOn").onclick = () => {
      setError("");
      ws.send(JSON.stringify({type:"controller_on"}));
    };
    document.getElementById("btnOff").onclick = () => {
      setError("");
      ws.send(JSON.stringify({type:"controller_off"}));
    };

    ws.onopen = () => {
      wsBadge.textContent = "WS: 연결됨";
      wsBadge.className = "badge on";
    };

    ws.onmessage = async (e) => {
      const msg = JSON.parse(e.data);

      if(msg.type === "hello"){
        myId = msg.client_id;
        updateControllerUI();
        updateStatusLine();
        return;
      }

      if(msg.type === "snapshot"){
        controllerId = msg.controller_id;
        currentPdfId = msg.pdf_id;
        currentPage = msg.page;
        updateControllerUI();
        updateStatusLine();
        await loadAndRender(currentPdfId, currentPage);
        return;
      }

      if(msg.type === "controller_changed"){
        controllerId = msg.controller_id;
        updateControllerUI();
        updateStatusLine();
        return;
      }

      if(msg.type === "state_changed"){
        currentPdfId = msg.pdf_id;
        currentPage = msg.page;
        updateStatusLine();
        await loadAndRender(currentPdfId, currentPage);
        return;
      }

      if(msg.type === "error"){
        setError(msg.message || "오류");
      }
    };

    ws.onerror = () => {
      wsBadge.textContent = "WS: 오류";
      wsBadge.className = "badge off";
      setError("WebSocket 연결 오류(브라우저 콘솔 확인)");
    };

    ws.onclose = () => {
      wsBadge.textContent = "WS: 종료됨";
      wsBadge.className = "badge off";
      setError("연결이 종료되었습니다(페이지 새로고침 후 재시도).");
    };
  </script>
</body>
</html>
